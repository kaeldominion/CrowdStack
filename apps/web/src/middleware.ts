import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

/**
 * Middleware to:
 * 1. Proxy API requests to apps/app in local dev
 * 2. Refresh Supabase auth sessions
 */
export async function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  const isLocalDev = 
    process.env.NODE_ENV === "development" || 
    process.env.NEXT_PUBLIC_APP_ENV === "local";

  // Proxy Next.js static chunks for admin/app/door routes to apps/app
  // When you're on /admin/venues, Next.js requests chunks that are generated by apps/app
  // We need to proxy ALL static assets requested from those pages to apps/app
  if (isLocalDev && pathname.startsWith("/_next/static/")) {
    const referer = request.headers.get("referer");
    console.log("[Middleware Proxy] ðŸ” Static asset request:", {
      pathname,
      referer: referer || "NO REFERER",
      method: request.method,
    });
    
    // Check if request is coming from an admin/app/door page
    // Handle both /app and /app/ patterns
    const hasAdminPath = referer?.includes("/admin/") ?? false;
    const hasAppPath = referer ? (referer.includes("/app") && !referer.includes("/api/") && !referer.includes("/app/health")) : false;
    const hasDoorPath = referer?.includes("/door/") ?? false;
    const isFromAdminApp = hasAdminPath || hasAppPath || hasDoorPath;
    
    // Also check chunk path itself for app-specific routes
    // Next.js generates paths like: /_next/static/chunks/app/admin/venues/page.js
    // Or: /_next/static/css/app/layout.css
    // Use a more general pattern to catch all app chunks
    const chunkPathIncludesAppRoutes = 
      pathname.includes("/chunks/app/") ||  // General pattern for all app chunks
      pathname.includes("/chunks/app/admin/") || 
      pathname.includes("/chunks/app/venue/") ||
      pathname.includes("/chunks/app/organizer/") ||
      pathname.includes("/chunks/app/promoter/") ||
      pathname.includes("/css/app/") ||
      pathname.includes("/media/") ||
      pathname.includes("main-app.js") ||
      pathname.includes("app-pages-internals.js");
    
    console.log("[Middleware Proxy] Static asset analysis:", {
      referer,
      hasAdminPath,
      hasAppPath,
      hasDoorPath,
      isFromAdminApp,
      chunkPathIncludesAppRoutes,
      shouldProxy: isFromAdminApp || chunkPathIncludesAppRoutes,
    });
    
    // If coming from an admin/app/door page OR chunk path suggests it's from apps/app, try apps/app
    if (isFromAdminApp || chunkPathIncludesAppRoutes) {
      const appPort = process.env.APP_DEV_PORT || "3007";
      const proxyUrl = new URL(pathname + request.nextUrl.search, `http://localhost:${appPort}`);
      
      console.log("[Middleware Proxy] âœ… Proxying static asset to apps/app:", proxyUrl.toString());
      
      try {
        const proxyResponse = await fetch(proxyUrl.toString(), {
          method: request.method,
          headers: {
            ...Object.fromEntries(request.headers.entries()),
          },
        });
        
        console.log("[Middleware Proxy] Proxy response:", {
          status: proxyResponse.status,
          ok: proxyResponse.ok,
          contentType: proxyResponse.headers.get("content-type"),
        });
        
        if (proxyResponse.ok) {
          console.log("[Middleware Proxy] âœ… Successfully proxied static asset from apps/app");
          const contentType = proxyResponse.headers.get("content-type") || "application/octet-stream";
          const responseBody = await proxyResponse.arrayBuffer();
          return new NextResponse(responseBody, {
            status: proxyResponse.status,
            statusText: proxyResponse.statusText,
            headers: {
              ...Object.fromEntries(proxyResponse.headers.entries()),
              "content-type": contentType,
            },
          });
        } else {
          console.log("[Middleware Proxy] âš ï¸ Static asset not found in apps/app (status:", proxyResponse.status, "), falling back to web app");
        }
      } catch (error) {
        console.error("[Middleware Proxy] âŒ Error proxying static chunk from apps/app:", error);
        console.error("[Middleware Proxy] Error details:", error instanceof Error ? error.stack : error);
        // Continue to let web app try to serve it
      }
    } else {
      console.log("[Middleware Proxy] â­ï¸ Not proxying - doesn't match admin/app/door pattern");
    }
  }

  // Proxy API routes to apps/app in local dev
  if (isLocalDev && pathname.startsWith("/api/")) {
    const appPort = process.env.APP_DEV_PORT || "3007";
    const appApiRoutes = [
      "/api/admin",
      "/api/organizer",
      "/api/venue",
      "/api/promoter",
      "/api/events",
      "/api/debug",
      "/api/door",
    ];

    // Check if this is an API route that should be proxied
    const shouldProxy = appApiRoutes.some((route) => pathname.startsWith(route));

    // Don't proxy web-specific API routes
    if (shouldProxy && !pathname.startsWith("/api/web")) {
      try {
        const proxyUrl = new URL(request.nextUrl.pathname + request.nextUrl.search, `http://localhost:${appPort}`);
        
        console.log("[Middleware Proxy] Proxying API request:", {
          pathname,
          method: request.method,
          proxyUrl: proxyUrl.toString(),
        });
        
        // Collect cookies to forward
        const allCookies = request.cookies.getAll();
        const cookieHeader = allCookies
          .map((cookie) => `${cookie.name}=${cookie.value}`)
          .join("; ");
        
        console.log("[Middleware Proxy] Cookies found:", allCookies.map(c => c.name).join(", "));
        console.log("[Middleware Proxy] Cookie header length:", cookieHeader.length);
        
        // Build headers for proxy request
        const proxyHeaders: Record<string, string> = {};
        
        // Copy relevant headers (exclude host and connection)
        request.headers.forEach((value, key) => {
          const lowerKey = key.toLowerCase();
          if (!["host", "connection", "cookie"].includes(lowerKey)) {
            proxyHeaders[key] = value;
          }
        });
        
        // Add cookies
        if (cookieHeader) {
          proxyHeaders["Cookie"] = cookieHeader;
        }
        
        // Get request body for POST/PUT/PATCH requests
        let requestBody: string | undefined = undefined;
        if (request.method !== "GET" && request.method !== "HEAD") {
          try {
            requestBody = await request.text();
            // If body is empty string, set to undefined
            if (requestBody === "") {
              requestBody = undefined;
            }
          } catch (e) {
            // If body can't be read, continue without it
            requestBody = undefined;
          }
        }
        
        console.log("[Middleware Proxy] Forwarding request to:", proxyUrl.toString());
        
        // Forward the request to apps/app
        const proxyResponse = await fetch(proxyUrl.toString(), {
          method: request.method,
          headers: proxyHeaders,
          body: requestBody,
        });

        console.log("[Middleware Proxy] Response status:", proxyResponse.status, proxyResponse.statusText);

        // Return proxied response
        const responseBody = await proxyResponse.text();
        
        console.log("[Middleware Proxy] Response body length:", responseBody.length);
        if (proxyResponse.status !== 200) {
          console.error("[Middleware Proxy] Error response body:", responseBody.substring(0, 500));
        }
        
        const response = new NextResponse(responseBody, {
          status: proxyResponse.status,
          statusText: proxyResponse.statusText,
          headers: {
            ...Object.fromEntries(proxyResponse.headers.entries()),
          },
        });

        return response;
      } catch (error) {
        console.error("[Middleware Proxy] ERROR proxying API request to apps/app:", error);
        console.error("[Middleware Proxy] Pathname:", pathname);
        console.error("[Middleware Proxy] Proxy URL would be:", `http://localhost:${appPort}${pathname}`);
        console.error("[Middleware Proxy] Error details:", error instanceof Error ? error.stack : error);
        return NextResponse.json(
          { error: "Failed to proxy API request", details: error instanceof Error ? error.message : "Unknown error" },
          { status: 502 }
        );
      }
    }
  }

  // Normal middleware flow for non-API routes
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    return response;
  }

  const supabase = createServerClient(supabaseUrl, supabaseAnonKey, {
    cookies: {
      getAll() {
        return request.cookies.getAll();
      },
      setAll(cookiesToSet: Array<{ name: string; value: string; options?: any }>) {
        cookiesToSet.forEach(({ name, value, options }) => {
          request.cookies.set(name, value);
          response.cookies.set(name, value, options);
        });
      },
    },
  });

  // Just refresh session - no redirects
  await supabase.auth.getUser();

  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths including _next/static for proxying
     * We need to proxy static assets from apps/app
     */
    "/((?!_next/image|favicon.ico).*)",
  ],
};

